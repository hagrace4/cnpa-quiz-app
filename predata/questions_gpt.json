{
  "exam": "Certified Cloud Native Platform Engineering Associate",
  "short_code": "CNPA",
  "provider": "CNCF / Linux Foundation",
  "version": "2025-12-06",
  "source": "Unofficial practice questions generated by ChatGPT based on public CNPA exam domains.",
  "questions": [
    {
      "id": "CNPA-001",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Declarative Resource Management",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "A platform team is migrating from shell scripts that call cloud CLIs to a GitOps-driven model using Kubernetes manifests and Terraform. Which statement best describes the \"declarative\" approach they are moving toward?",
      "options": [
        { "id": "A", "text": "The platform team writes scripts that describe each step needed to provision resources in the correct order." },
        { "id": "B", "text": "The platform team defines the desired end-state of resources, and automated controllers continuously reconcile actual state to match it." },
        { "id": "C", "text": "The platform team provisions infrastructure manually once, then treats it as immutable and never changes it." },
        { "id": "D", "text": "The platform team relies on ticket-based processes so that operations can approve every change." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "Declarative management focuses on describing the desired end-state of the system (for example, via YAML manifests or Terraform code). Controllers and tools then continuously reconcile actual state to the declared state, instead of running step-by-step imperative scripts.",
      "tags": ["declarative", "gitops", "infrastructure-as-code"]
    },
    {
      "id": "CNPA-002",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Platform Engineering Goals, Objectives, and Approaches",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "Which option best captures the idea of treating an internal developer platform (IDP) as a product?",
      "options": [
        { "id": "A", "text": "Prioritizing infrastructure uptime only, without gathering feedback from developers." },
        { "id": "B", "text": "Letting each application team build and operate its own platform independently." },
        { "id": "C", "text": "Defining clear users, value propositions, roadmaps, and feedback loops for the platform, similar to an external SaaS product." },
        { "id": "D", "text": "Focusing exclusively on cost optimization for infrastructure, regardless of developer experience." }
      ],
      "correct_option_ids": ["C"],
      "explanation": "Platform engineering emphasizes \"platform as a product\": you identify developer personas, clarify the platform’s value, maintain a roadmap, and use feedback and metrics to drive continuous improvement.",
      "tags": ["platform-as-a-product", "idp", "product-thinking"]
    },
    {
      "id": "CNPA-003",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Platform Engineering Goals, Objectives, and Approaches",
      "difficulty": "medium",
      "question_type": "multiple_select",
      "question_text": "A platform team's primary goal is to reduce cognitive load on application teams. Which TWO actions align with this goal?",
      "options": [
        { "id": "A", "text": "Publishing opinionated golden-path templates for common workloads, including CI/CD and observability defaults." },
        { "id": "B", "text": "Requiring each team to design its own networking, security groups, and Kubernetes clusters from scratch." },
        { "id": "C", "text": "Providing a self-service portal where developers can request standardized environments with minimal inputs." },
        { "id": "D", "text": "Centralizing all deployments in a shared chat channel where operations manually run scripts on request." }
      ],
      "correct_option_ids": ["A", "C"],
      "explanation": "Reducing cognitive load means hiding platform complexity behind opinionated defaults and self-service workflows. Golden paths and simple self-service requests help developers focus on business logic rather than infrastructure details.",
      "tags": ["cognitive-load", "golden-paths", "self-service"]
    },
    {
      "id": "CNPA-004",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Application Environments and Infrastructure Concepts",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "A platform engineer is standardizing environment definitions for dev, staging, and prod across multiple applications. Which practice best supports consistency and repeatability?",
      "options": [
        { "id": "A", "text": "Creating separate hand-written runbooks for each application and environment." },
        { "id": "B", "text": "Using a single shared production cluster with no separation of namespaces or policies." },
        { "id": "C", "text": "Defining environment configuration as code (for example, via Helm values or Kustomize overlays) that can be reused across applications." },
        { "id": "D", "text": "Letting each team individually define environments using their own ad-hoc conventions." }
      ],
      "correct_option_ids": ["C"],
      "explanation": "Defining environment configuration as code allows you to reuse patterns, enforce standards, and minimize drift between dev, staging, and production.",
      "tags": ["environments", "configuration-as-code", "standardization"]
    },
    {
      "id": "CNPA-005",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "DevOps Practices in Platform Engineering",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "How does platform engineering most directly extend traditional DevOps practices?",
      "options": [
        { "id": "A", "text": "By replacing DevOps with centralized operations teams and ticket queues." },
        { "id": "B", "text": "By focusing solely on infrastructure reliability and ignoring developer experience." },
        { "id": "C", "text": "By building reusable self-service tools, abstractions, and workflows that make DevOps practices scalable across many teams." },
        { "id": "D", "text": "By requiring every developer to become an expert in Kubernetes and cloud networking." }
      ],
      "correct_option_ids": ["C"],
      "explanation": "Platform engineering builds on DevOps by creating reusable, self-service capabilities (like templates, pipelines, and APIs) that scale DevOps practices across many product teams while improving developer experience.",
      "tags": ["devops", "platform-engineering", "self-service"]
    },
    {
      "id": "CNPA-006",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Continuous Integration Fundamentals",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "Which outcome is the strongest indicator that continuous integration (CI) is working effectively for a platform?",
      "options": [
        { "id": "A", "text": "Developers merge code directly to the main branch only once per month." },
        { "id": "B", "text": "Every commit triggers automated builds and tests, with fast feedback when a change breaks the main branch." },
        { "id": "C", "text": "All test execution is manual but documented in a runbook." },
        { "id": "D", "text": "Releases are manually assembled from multiple long-lived branches before deployment." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "Effective CI provides rapid, automated feedback on every change, enabling small, frequent merges and catching integration issues early.",
      "tags": ["ci", "automation", "feedback-loops"]
    },
    {
      "id": "CNPA-007",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Continuous Delivery and GitOps",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "Which principle is core to GitOps for platform-managed workloads?",
      "options": [
        { "id": "A", "text": "Deployments are initiated manually from a web UI after tickets are approved." },
        { "id": "B", "text": "Git is the single source of truth for desired state, and controllers continuously reconcile running systems to match Git." },
        { "id": "C", "text": "Application containers are deployed directly from developer laptops to the cluster." },
        { "id": "D", "text": "Configuration changes are applied interactively using imperative kubectl commands on production clusters." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "GitOps treats Git as the canonical source of desired state. Automated agents reconcile the running system with what is declared in Git, providing versioning, auditability, and repeatability.",
      "tags": ["gitops", "desired-state", "reconciliation"]
    },
    {
      "id": "CNPA-008",
      "domain": "Platform Engineering Core Fundamentals",
      "topic": "Application Environments and Infrastructure Concepts",
      "difficulty": "medium",
      "question_type": "multiple_select",
      "question_text": "A platform team is designing a multi-tenant Kubernetes cluster for several product teams. Which TWO practices best support safe multi-tenancy?",
      "options": [
        { "id": "A", "text": "Using separate namespaces per team with appropriate RBAC and network policies." },
        { "id": "B", "text": "Granting all developers cluster-admin so they can troubleshoot issues quickly." },
        { "id": "C", "text": "Enforcing resource quotas and limit ranges per namespace." },
        { "id": "D", "text": "Sharing a single namespace across all teams to simplify configuration." }
      ],
      "correct_option_ids": ["A", "C"],
      "explanation": "Namespaces with RBAC and network policies provide isolation between teams, while resource quotas and limits prevent noisy neighbors from consuming all resources in a shared cluster.",
      "tags": ["multi-tenancy", "kubernetes", "security", "resource-management"]
    },
    {
      "id": "CNPA-009",
      "domain": "Platform Observability, Security, and Conformance",
      "topic": "Observability Fundamentals: Traces, Metrics, Logs, and Events",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "Which combination represents the four primary signals of observability in a modern cloud native platform?",
      "options": [
        { "id": "A", "text": "Metrics, logs, traces, and events." },
        { "id": "B", "text": "CPU, memory, disk, and network." },
        { "id": "C", "text": "Requests, errors, latency, and saturation." },
        { "id": "D", "text": "Dashboards, alerts, runbooks, and on-call schedules." }
      ],
      "correct_option_ids": ["A"],
      "explanation": "Common observability guidance groups telemetry into four signals: metrics, logs, traces, and events, which together provide a holistic view of platform behavior.",
      "tags": ["observability", "telemetry", "signals"]
    },
    {
      "id": "CNPA-010",
      "domain": "Platform Observability, Security, and Conformance",
      "topic": "Observability Fundamentals: Traces, Metrics, Logs, and Events",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "A team sees an increase in error rate on a service-level objective (SLO) dashboard. What is the BEST next step to understand which specific requests are failing and why?",
      "options": [
        { "id": "A", "text": "Check only high-level CPU metrics for the entire cluster." },
        { "id": "B", "text": "Inspect distributed traces and correlated logs for the affected service." },
        { "id": "C", "text": "Increase the pod replica count for all services in the namespace." },
        { "id": "D", "text": "Rotate application secrets and redeploy the platform." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "SLO dashboards surface symptoms. To understand which requests are failing and the root cause, you typically drill into distributed traces and correlated logs for the specific service or route.",
      "tags": ["slo", "traces", "logs", "troubleshooting"]
    },
    {
      "id": "CNPA-011",
      "domain": "Platform Observability, Security, and Conformance",
      "topic": "Secure Service Communication",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "In a service mesh used by the platform, what is the primary security benefit of enabling mutual TLS (mTLS) between services?",
      "options": [
        { "id": "A", "text": "It compresses network traffic to reduce bandwidth costs." },
        { "id": "B", "text": "It automatically scales services up and down based on load." },
        { "id": "C", "text": "It encrypts traffic in transit and authenticates both the client and server." },
        { "id": "D", "text": "It replaces the need for any network policies or firewalls." }
      ],
      "correct_option_ids": ["C"],
      "explanation": "Mutual TLS (mTLS) provides encryption in transit and ensures both ends of a connection can authenticate each other, improving service-to-service security.",
      "tags": ["mtls", "service-mesh", "network-security"]
    },
    {
      "id": "CNPA-012",
      "domain": "Platform Observability, Security, and Conformance",
      "topic": "Kubernetes Security Essentials",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "Which practice aligns BEST with the principle of least privilege in a Kubernetes-based platform?",
      "options": [
        { "id": "A", "text": "Assigning cluster-admin to all CI/CD service accounts to avoid permission errors." },
        { "id": "B", "text": "Creating narrowly scoped Roles and RoleBindings for each service account to grant only the permissions it needs." },
        { "id": "C", "text": "Disabling authentication and relying on network firewalls only." },
        { "id": "D", "text": "Using a single service account for all workloads in the cluster." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "Least privilege means granting only the permissions that are strictly necessary. In Kubernetes, this is implemented by creating specific Roles and binding them to individual service accounts as needed.",
      "tags": ["rbac", "least-privilege", "security"]
    },
    {
      "id": "CNPA-013",
      "domain": "Continuous Delivery & Platform Engineering",
      "topic": "Continuous Integration Pipelines Overview",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "Which sequence BEST represents a typical CI pipeline for a microservice managed by the platform?",
      "options": [
        { "id": "A", "text": "Clone repo → run tests → build container image → push image → publish test reports." },
        { "id": "B", "text": "Manually edit production manifests → deploy to production → run tests → push code to Git." },
        { "id": "C", "text": "Build container image → modify code directly in the cluster → commit changes later." },
        { "id": "D", "text": "Run performance tests only → deploy directly to production." }
      ],
      "correct_option_ids": ["A"],
      "explanation": "A standard CI pipeline pulls code, runs automated tests, builds and tags an artifact (such as a container image), pushes it to a registry, and publishes test results for feedback.",
      "tags": ["ci", "pipelines", "automation"]
    },
    {
      "id": "CNPA-014",
      "domain": "Continuous Delivery & Platform Engineering",
      "topic": "CI/CD Relationship Fundamentals",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "In a well-designed platform, how do CI and CD typically interact?",
      "options": [
        { "id": "A", "text": "CI pipelines deploy directly to production without any intermediate stages." },
        { "id": "B", "text": "CI produces tested, versioned artifacts; CD consumes those artifacts and automates their promotion through environments." },
        { "id": "C", "text": "CD runs unit tests, while CI runs only end-to-end tests." },
        { "id": "D", "text": "CI and CD both independently build separate container images for the same commit." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "CI focuses on building and testing code, producing versioned artifacts. CD then orchestrates the promotion of those artifacts through environments toward production using automated workflows.",
      "tags": ["ci", "cd", "separation-of-concerns"]
    },
    {
      "id": "CNPA-015",
      "domain": "Continuous Delivery & Platform Engineering",
      "topic": "GitOps for Application Environments",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "A deployment caused an outage shortly after a GitOps controller applied a new commit to the production environment repo. What is the MOST GitOps-aligned rollback strategy?",
      "options": [
        { "id": "A", "text": "Manually edit resources in the cluster using kubectl to undo the change." },
        { "id": "B", "text": "Force-restart all pods in the namespace and hope the issue resolves." },
        { "id": "C", "text": "Revert the problematic commit in Git and let the GitOps controller reconcile the cluster back to the previous state." },
        { "id": "D", "text": "Manually scale the deployment to zero and leave it that way permanently." }
      ],
      "correct_option_ids": ["C"],
      "explanation": "In GitOps, you roll back by reverting or adjusting Git history so controllers reconcile the cluster back to a known good state, rather than manually editing cluster resources.",
      "tags": ["gitops", "rollback", "production"]
    },
    {
      "id": "CNPA-016",
      "domain": "Platform APIs and Provisioning Infrastructure",
      "topic": "Kubernetes Reconciliation Loop",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "Which description BEST explains the Kubernetes reconciliation loop from a platform perspective?",
      "options": [
        { "id": "A", "text": "A one-time script that provisions a cluster when it is first created." },
        { "id": "B", "text": "A continuous process where controllers observe the current cluster state and make changes to drive it toward the desired state defined in resources." },
        { "id": "C", "text": "A manual checklist operators follow before each deployment." },
        { "id": "D", "text": "A security feature that prevents any changes to cluster resources." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "Kubernetes controllers implement reconciliation loops: they continuously compare the current state with the desired state declared in resources and take actions to converge the two.",
      "tags": ["reconciliation-loop", "controllers", "desired-state"]
    },
    {
      "id": "CNPA-017",
      "domain": "Platform APIs and Provisioning Infrastructure",
      "topic": "APIs for Self-Service Platforms (CRDs)",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "A platform team introduces a custom resource definition (CRD) called \"ApplicationEnvironment\" that encapsulates namespaces, network policies, and observability defaults. What is the MAIN benefit of exposing this as a CRD to application teams?",
      "options": [
        { "id": "A", "text": "It allows developers to bypass the platform team and edit the Kubernetes API server configuration directly." },
        { "id": "B", "text": "It gives developers a higher-level, opinionated API to request environments without understanding all the underlying Kubernetes resources." },
        { "id": "C", "text": "It forces every team to run its own Kubernetes control plane." },
        { "id": "D", "text": "It eliminates the need for any validation or governance on platform resources." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "CRDs let platform teams design higher-level, opinionated APIs. Developers can request complex capabilities (like environments) via a simple spec, while controllers handle the details and enforce standards.",
      "tags": ["crd", "self-service", "abstractions"]
    },
    {
      "id": "CNPA-018",
      "domain": "IDPs and Developer Experience",
      "topic": "Developer Portals for Platform Adoption",
      "difficulty": "easy",
      "question_type": "single_choice",
      "question_text": "Why might a platform team adopt a developer portal such as Backstage for their internal developer platform (IDP)?",
      "options": [
        { "id": "A", "text": "To expose raw infrastructure APIs directly without any opinionated defaults." },
        { "id": "B", "text": "To provide a single entry point where developers can discover services, documentation, templates, and self-service actions." },
        { "id": "C", "text": "To replace all CI/CD systems with a monolithic web console." },
        { "id": "D", "text": "To prevent developers from seeing which services exist in the organization." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "Developer portals give teams a central place to discover services, documentation, and golden-path templates, and to trigger self-service actions, improving platform adoption and developer experience.",
      "tags": ["developer-portal", "backstage", "idp"]
    },
    {
      "id": "CNPA-019",
      "domain": "IDPs and Developer Experience",
      "topic": "AI/ML in Platform Automation",
      "difficulty": "medium",
      "question_type": "single_choice",
      "question_text": "Which example BEST illustrates a responsible use of AI/ML in a platform engineering context?",
      "options": [
        { "id": "A", "text": "Automatically merging any pull request that mentions \"fix\" in the title." },
        { "id": "B", "text": "Using ML-based anomaly detection on metrics to suggest likely root causes and related dashboards during incidents." },
        { "id": "C", "text": "Letting a chatbot directly modify production cluster configuration without human review." },
        { "id": "D", "text": "Replacing all security policies with a black-box AI model that cannot be audited." }
      ],
      "correct_option_ids": ["B"],
      "explanation": "AI/ML can augment platform operations by, for example, detecting anomalies in telemetry and suggesting likely causes or dashboards. High-risk actions, such as direct production changes, should still require human review and auditable policies.",
      "tags": ["ai", "ml", "observability", "incident-response"]
    },
    {
      "id": "CNPA-020",
      "domain": "Measuring your Platform",
      "topic": "DORA Metrics for Platform Initiatives",
      "difficulty": "easy",
      "question_type": "multiple_select",
      "question_text": "Which TWO metrics are part of the commonly referenced DORA metrics used to evaluate software delivery performance?",
      "options": [
        { "id": "A", "text": "Deployment frequency." },
        { "id": "B", "text": "Lead time for changes." },
        { "id": "C", "text": "Total number of microservices in the organization." },
        { "id": "D", "text": "Number of lines of code per service." }
      ],
      "correct_option_ids": ["A", "B"],
      "explanation": "DORA metrics include deployment frequency, lead time for changes, change failure rate, and mean time to restore (MTTR). They help assess delivery performance rather than code size or service count.",
      "tags": ["dora", "metrics", "delivery-performance"]
    }
  ]
}
